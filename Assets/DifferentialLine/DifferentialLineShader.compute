#pragma kernel updateKernel
#pragma kernel resetKernel
#pragma kernel renderKernel
#pragma kernel resetTextureKernel
#pragma kernel appendKernel
#pragma enable_d3d11_debug_symbols

//---- INCLUDES

#include "Assets/Common/ShaderUtilities/random.hlsl"

//---- CONSTANTS

#define NUMTHREADS_POINTS 32
#define NUMTHREADS_RESOLUTION 32

#define EPSILON .000001
#define DIMENSIONS 100.0
#define PI 3.14

//----- NODES

struct Node
{
	float2 position;
	int previous;
	int next;
};
RWStructuredBuffer<Node> writeBuffer;
RWStructuredBuffer<Node> writeBuffer2; //used for appendKernel - we must write to both at the same time
StructuredBuffer<Node> readBuffer;

//------ VARIABLES

const int resolution;
const float aspectRatio;
const int maxCount;
const float initialRadius;
const int initialCount;

const float maxConnectionLength;

const float repulsionRadius;
const float minNeighborDist;

const float movementSpeed;
const float deltaTime;
const int step;

const int nodeCount;

RWTexture2D<float4> outTexture;

RWStructuredBuffer<RandState> randStates;

const float fadeCoefficient;
const int nodeSize;

float2 constrainByDistance(float2 toConstrain, float2 constraint, float distance) 
{
	const float2 delta = toConstrain - constraint;
	const float dist = length(delta);
	if (dist > distance) 
	{
		const float2 direction = delta / dist;
		return constraint + direction * distance;
	}
	else 
	{
		return toConstrain;
	}
}

[numthreads(NUMTHREADS_POINTS, 1, 1)]
void updateKernel(uint3 id : SV_DispatchThreadID)
{
	Node currentNode = readBuffer[id.x];

	float2 repulsionMovement = float2(.0, .0);
	for (int i = 0; i < nodeCount; i++)
	{
		if (i == (int)id.x
			|| i == currentNode.previous
			|| i == currentNode.next)
		{
			continue;
		}

		Node otherNode = readBuffer[i];
		const float2 delta = currentNode.position - otherNode.position;
		const float deltaLength = length(delta);
		if (deltaLength > EPSILON && deltaLength <= repulsionRadius)
		{
			repulsionMovement += delta / deltaLength;
		}
	}
	
	const float movementLength = length(repulsionMovement);
	if (movementLength > EPSILON)
	{
		currentNode.position += repulsionMovement / movementLength * movementSpeed * deltaTime;

		//neighbor nodes, want to get closer (within a threshold)
		const Node previousNode = readBuffer[currentNode.previous];
		const Node nextNode = readBuffer[currentNode.next]; 
		currentNode.position = constrainByDistance(currentNode.position, nextNode.position, minNeighborDist);
		currentNode.position = constrainByDistance(currentNode.position, previousNode.position, minNeighborDist);
		writeBuffer[id.x] = currentNode;
	}
}

[numthreads(NUMTHREADS_POINTS, 1, 1)]
void resetKernel(uint3 id : SV_DispatchThreadID)
{
	const float angle = (float)id.x / (float)initialCount * 2.0 * PI;
	const float2 position = DIMENSIONS * (float2(.5*aspectRatio, .5) + initialRadius * float2(cos(angle), sin(angle)));

	int previous = ((int)id.x) - 1;
	if (previous < 0) previous = initialCount - 1;

	int next = id.x + 1;
	if (next >= initialCount) next = 0;

	Node node;
	node.position = position;
	node.previous = previous;
	node.next = next;
	writeBuffer[id.x] = node;
}

// ----- Texture Kernels

int2 getCoords(float2 position) 
{
	return position * float2(resolution, resolution) / DIMENSIONS;
}

bool withinScreen(int2 coords)
{
	return coords.x > 0 && coords.y > 0 && coords.x < resolution*aspectRatio && coords.y < resolution;
}

void drawCircle(float2 centerPosition)
{
	const int2 center = getCoords(centerPosition);
	int2 start = center - nodeSize;
	int2 end = center + nodeSize;

	for(int y = start.y; y <= end.y; y++)
	for(int x = start.x; x <= end.x; x++)
	{
		const int2 currentCoord = int2(x, y);
		const int dist = distance(currentCoord, center);
		if (dist <= nodeSize)
		{
			const float color = .5 + .5 * smoothstep(.0, 1.0, 1.0 - (float)dist / (float)nodeSize);
			outTexture[currentCoord] += float4(color, color, color, 1.0);
		}
	}
}


[numthreads(NUMTHREADS_POINTS, 1, 1)]
void renderKernel(uint3 id : SV_DispatchThreadID)
{
	if ((int)id.x >= nodeCount)
	{
		return;
	}

	const Node node = readBuffer[id.x];

	drawCircle(node.position);
}


[numthreads(NUMTHREADS_RESOLUTION, NUMTHREADS_RESOLUTION, 1)]
void resetTextureKernel(uint3 id : SV_DispatchThreadID) 
{
	outTexture[id.xy] = outTexture[id.xy] * fadeCoefficient;
}

// ----- Append Kernel

int getRandomIndex(uint id, int range) 
{
	uint randSeed = wangHash(id + step);
	const float random01 = rand(randSeed);
	return random01 * (range - .5);
}

const int nodesToAppend;

[numthreads(1, 1, 1)]
void appendKernel(uint3 id : SV_DispatchThreadID)
{
	for (int i = 0; i < nodesToAppend; i++) 
	{
		const int newIndex = nodeCount+i;

		const int chosenIndex = getRandomIndex(id.x, newIndex);

		Node chosenNode = writeBuffer[chosenIndex];
		const int nextIndex = chosenNode.next;
		Node nextNode = writeBuffer[nextIndex];

		nextNode.previous = newIndex;
		chosenNode.next = newIndex;

		Node appendedNode;
		appendedNode.position = lerp(chosenNode.position, nextNode.position, .5);
		appendedNode.previous = chosenIndex;
		appendedNode.next = nextIndex;

		writeBuffer[newIndex] = appendedNode;
		writeBuffer[nextIndex] = nextNode;
		writeBuffer[chosenIndex] = chosenNode;

		writeBuffer2[newIndex] = appendedNode;
		writeBuffer2[nextIndex] = nextNode;
		writeBuffer2[chosenIndex] = chosenNode;
	}
}