#pragma kernel updateKernel
#pragma kernel resetKernel
#pragma kernel renderKernel
#pragma kernel resetTextureKernel
#pragma enable_d3d11_debug_symbols

//---- CONSTANTS

#define NUMTHREADS_POINTS 32
#define NUMTHREADS_RESOLUTION 32

#define EPSILON .000001
#define DIMENSIONS 100.0
#define PI 3.14

//----- NODES

struct Node
{
	float2 position;
	uint previous;
	uint next;
};
RWStructuredBuffer<Node> writeBuffer;
StructuredBuffer<Node> readBuffer;

//------ COUNT

struct Count
{
	int value;
};
RWStructuredBuffer<Count> countBuffer;
int getCount() 
{
	return countBuffer[0].value;
}

int getAndIncrementCount()
{
	uint result;
	InterlockedAdd(countBuffer[0].value, 1, result);
	return result;
}

//------ VARIABLES

int resolution;
int maxCount;
float initialRadius;
int initialCount;

float maxConnectionLength;

float repulsionRadius;
float minNeighborDist;

float movementSpeed;
float deltaTime;


RWTexture2D<float4> outTexture;

float2 constrainByDistance(float2 toConstrain, float2 constraint, float distance) 
{
	const float2 delta = toConstrain - constraint;
	const float dist = length(delta);
	if (dist > distance) 
	{
		const float2 direction = delta / dist;
		return constraint + direction * distance;
	}
	else 
	{
		return toConstrain;
	}
}

[numthreads(NUMTHREADS_POINTS, 1, 1)]
void updateKernel(uint3 id : SV_DispatchThreadID)
{
	Node currentNode = readBuffer[id.x];

	const uint nodeCount = getCount();
	float2 repulsionMovement = float2(.0, .0);
	for (uint i = 0; i < nodeCount; i++)
	{
		if (i == id.x
			|| i == currentNode.previous
			|| i == currentNode.next)
		{
			continue;
		}

		Node otherNode = readBuffer[i];
		const float2 delta = currentNode.position - otherNode.position;
		const float deltaLength = length(delta);
		if (deltaLength > EPSILON && deltaLength <= repulsionRadius)
		{
			repulsionMovement += delta / deltaLength;
		}
	}
	
	const float movementLength = length(repulsionMovement);
	if (movementLength > EPSILON)
	{
		currentNode.position += repulsionMovement / movementLength * movementSpeed * deltaTime;

		//neighbor nodes, want to get closer (within a threshold)
		const Node previousNode = readBuffer[currentNode.previous];
		const Node nextNode = readBuffer[currentNode.next]; 
		currentNode.position = constrainByDistance(currentNode.position, nextNode.position, minNeighborDist);
		currentNode.position = constrainByDistance(currentNode.position, previousNode.position, minNeighborDist);
		writeBuffer[id.x] = currentNode;
	}
}

[numthreads(NUMTHREADS_POINTS, 1, 1)]
void resetKernel(uint3 id : SV_DispatchThreadID)
{
	const float angle = (float)id.x / (float)initialCount * 2.0 * PI;
	const float2 position = DIMENSIONS * (float2(.5,.5) + initialRadius * float2(cos(angle), sin(angle)));

	int previous = ((int)id.x) - 1;
	if (previous < 0) previous = initialCount - 1;

	uint next = id.x + 1;
	if (next >= (uint)initialCount) next = 0;

	Node node;
	node.position = position;
	node.previous = previous;
	node.next = next;
	writeBuffer[id.x] = node;
}


int2 getCoords(float2 position) 
{
	return position * (float)resolution / DIMENSIONS;
}

bool withinScreen(int2 coords)
{
	return coords.x > 0 && coords.y > 0 && coords.x < resolution && coords.y < resolution;
}

[numthreads(NUMTHREADS_POINTS, 1, 1)]
void renderKernel(uint3 id : SV_DispatchThreadID)
{
	const Node node = readBuffer[id.x];
	const int2 nodeCoords = getCoords(node.position);
	outTexture[nodeCoords] = float4(1.0, 1.0, 1.0, 1.0);
}

[numthreads(NUMTHREADS_RESOLUTION, NUMTHREADS_RESOLUTION, 1)]
void resetTextureKernel(uint3 id : SV_DispatchThreadID) 
{
	outTexture[id.xy] = float4(.0, .0, .0, 1.0);
}