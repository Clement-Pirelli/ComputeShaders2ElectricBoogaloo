#pragma kernel updateKernel
#pragma kernel resetKernel
#pragma kernel renderKernel
#pragma kernel resetTextureKernel
#pragma kernel appendKernel
#pragma enable_d3d11_debug_symbols

//---- INCLUDES

#include "Assets/Common/ShaderUtilities/random.hlsl"

//---- CONSTANTS

#define NUMTHREADS_POINTS 32
#define NUMTHREADS_RESOLUTION 32

#define EPSILON .000001
#define DIMENSIONS 100.0
#define PI 3.14

//----- NODES

struct Node
{
	float2 position;
	uint previous;
	uint next;
};
RWStructuredBuffer<Node> writeBuffer;
RWStructuredBuffer<Node> writeBuffer2; //used for appendKernel - we must write to both at the same time
StructuredBuffer<Node> readBuffer;

//------ COUNT

struct Count
{
	int value;
};
RWStructuredBuffer<Count> countBuffer;
int getCount() 
{
	return countBuffer[0].value;
}

int getAndIncrementCount()
{
	int result;
	InterlockedAdd(countBuffer[0].value, 1, result);
	return result;
}

//------ VARIABLES

int resolution;
float aspectRatio;
int maxCount;
float initialRadius;
int initialCount;

float maxConnectionLength;

float repulsionRadius;
float minNeighborDist;

float movementSpeed;
float deltaTime;
int step;

RWTexture2D<float4> outTexture;

RWStructuredBuffer<RandState> randStates;

float fadeCoefficient;

float2 constrainByDistance(float2 toConstrain, float2 constraint, float distance) 
{
	const float2 delta = toConstrain - constraint;
	const float dist = length(delta);
	if (dist > distance) 
	{
		const float2 direction = delta / dist;
		return constraint + direction * distance;
	}
	else 
	{
		return toConstrain;
	}
}

[numthreads(NUMTHREADS_POINTS, 1, 1)]
void updateKernel(uint3 id : SV_DispatchThreadID)
{
	Node currentNode = readBuffer[id.x];

	const uint nodeCount = getCount();
	float2 repulsionMovement = float2(.0, .0);
	for (uint i = 0; i < nodeCount; i++)
	{
		if (i == id.x
			|| i == currentNode.previous
			|| i == currentNode.next)
		{
			continue;
		}

		Node otherNode = readBuffer[i];
		const float2 delta = currentNode.position - otherNode.position;
		const float deltaLength = length(delta);
		if (deltaLength > EPSILON && deltaLength <= repulsionRadius)
		{
			repulsionMovement += delta / deltaLength;
		}
	}
	
	const float movementLength = length(repulsionMovement);
	if (movementLength > EPSILON)
	{
		currentNode.position += repulsionMovement / movementLength * movementSpeed * deltaTime;

		//neighbor nodes, want to get closer (within a threshold)
		const Node previousNode = readBuffer[currentNode.previous];
		const Node nextNode = readBuffer[currentNode.next]; 
		currentNode.position = constrainByDistance(currentNode.position, nextNode.position, minNeighborDist);
		currentNode.position = constrainByDistance(currentNode.position, previousNode.position, minNeighborDist);
		writeBuffer[id.x] = currentNode;
	}
}

[numthreads(NUMTHREADS_POINTS, 1, 1)]
void resetKernel(uint3 id : SV_DispatchThreadID)
{
	const float angle = (float)id.x / (float)initialCount * 2.0 * PI;
	const float2 position = DIMENSIONS * (float2(.5*aspectRatio, .5) + initialRadius * float2(cos(angle), sin(angle)));

	int previous = ((int)id.x) - 1;
	if (previous < 0) previous = initialCount - 1;

	uint next = id.x + 1;
	if (next >= (uint)initialCount) next = 0;

	Node node;
	node.position = position;
	node.previous = previous;
	node.next = next;
	writeBuffer[id.x] = node;
}

// ----- Texture Kernels

int2 getCoords(float2 position) 
{
	return position * float2(resolution, resolution) / DIMENSIONS;
}

bool withinScreen(int2 coords)
{
	return coords.x > 0 && coords.y > 0 && coords.x < resolution*aspectRatio && coords.y < resolution;
}

void drawCircle(float2 centerPosition)
{
	const float color = 1.4;
	const int circleRadius = 3;

	const int2 center = getCoords(centerPosition);
	int2 start = center - circleRadius;
	int2 end = center + circleRadius;

	for(int y = start.y; y <= end.y; y++)
	for(int x = start.x; x <= end.x; x++)
	{
		const int2 currentCoord = int2(x, y);
		if (distance(currentCoord, center) <= circleRadius)
		{
			outTexture[currentCoord] += float4(color, color, color, 1.0);
		}
	}
}


[numthreads(NUMTHREADS_POINTS, 1, 1)]
void renderKernel(uint3 id : SV_DispatchThreadID)
{
	if (id.x >= getCount()) 
	{
		return;
	}

	const Node node = readBuffer[id.x];

	drawCircle(node.position);
}


[numthreads(NUMTHREADS_RESOLUTION, NUMTHREADS_RESOLUTION, 1)]
void resetTextureKernel(uint3 id : SV_DispatchThreadID) 
{
	outTexture[id.xy] = outTexture[id.xy] * fadeCoefficient;
}

// ----- Append Kernel

int getRandomIndex(uint id, int range) 
{
	uint randSeed = wangHash(id + step);
	const float random01 = rand(randSeed);
	return random01 * (range - .5);
}


[numthreads(1, 1, 1)]
void appendKernel(uint3 id : SV_DispatchThreadID)
{
	const int newIndex = getAndIncrementCount();
	if (newIndex >= maxCount)
	{
		return; 
	}

	const int chosenIndex = getRandomIndex(id.x, newIndex);
	const int previousIndex = (chosenIndex == 0 ? newIndex : chosenIndex) - 1;

	Node previousNode = writeBuffer[previousIndex];
	Node nextNode = writeBuffer[previousNode.next];

	nextNode.previous = newIndex;
	previousNode.next = newIndex;

	Node appendedNode;
	appendedNode.position = lerp(previousNode.position, nextNode.position, .5);
	appendedNode.previous = previousIndex;
	appendedNode.next = chosenIndex;

	writeBuffer[newIndex] = appendedNode;
	writeBuffer[chosenIndex] = nextNode;
	writeBuffer[previousIndex] = previousNode;

	writeBuffer2[newIndex] = appendedNode;
	writeBuffer2[chosenIndex] = nextNode;
	writeBuffer2[previousIndex] = previousNode;
}