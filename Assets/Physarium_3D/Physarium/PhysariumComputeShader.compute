#pragma kernel ResetTextureKernel
#pragma kernel ResetAgentsKernel
#pragma kernel MoveAgentsKernel
#pragma kernel TrailsKernel
#pragma kernel RenderKernel
#pragma kernel DecayKernel
#pragma enable_d3d11_debug_symbols

Texture2D<float4> readTexture;
SamplerState sampler_readTexture;

RWTexture2D<float4> writeTexture;
RWTexture2D<float4> outTexture;

#define NUMTHREADS_AGENTS 64
#define NUMTHREADS_RESOLUTION 16

//sight
#define MAX_RANGE 10
int range;
float lineOfSight;

//trail
float trailDetectionThreshold;
float trailApproximationBias;
float trailStrengthPerAgent;
float trailDecayFactor;
float4 brightColor;
float4 dimColor;

//setup
int resolution;
float time;
int stepNumber;

struct Agent
{
	float2 position;
	float2 direction;
};

RWStructuredBuffer<Agent> agents;

bool randomReset;
Texture2D<float4> resetTexture;
SamplerState sampler_resetTexture;

////////////////////////////// UTILITIES ////////////////////////////////////////
bool isApproximately(float a, float b, float approx)
{
	return ((a - approx) <= b) && ((a + approx) > b);
}

float2 wrapPosition(float2 position)
{
	float2 outPosition = position;
	if (position.x < 0) outPosition.x = resolution - 1;
	if (position.y < 0) outPosition.y = resolution - 1;
	outPosition %= float2(resolution, resolution);
	return outPosition;
}

float2 rand(float2 p)
{
	p.y *= resolution;

	float3 p3 = frac(float3(p.xyx) * float3(.1031, .1030, .0973));
	p3 += dot(p3, p3.yzx + 33.33);
	return frac((p3.xx + p3.yz)*p3.zy);
}

float2 randDir(float2 randseed)
{
	const float angle = rand(randseed).x * 2.0 * 3.1415926524;
	return float2(cos(angle), sin(angle));
}

////////////////////////////// DIRECTION CHOICES ////////////////////////////////////////

float2 NeighborhoodTurns(uint3 id, Agent agent)
{
	float2 vectors[50]; //some samples might have the exact same amount of trail so we keep a record of the ones which are the same
	float maxTrail = .0;
	int vectorIndex = 0;

	for (int y = -range; y <= range; y++)
	for (int x = -range; x <= range; x++)
	{
		if (x == 0 && y == 0) continue;
		const float2 direction = float2(x, y);
		const float2 normalizedDirection = normalize(direction);
		if (dot(normalizedDirection, agent.direction) <= lineOfSight) continue;
		const uint2 coordinates = round(agent.position + direction);
		const float level = readTexture.SampleLevel(sampler_readTexture, coordinates / (float)resolution, .0).r;

		if (isApproximately(level, maxTrail, trailApproximationBias))
		{
			vectors[vectorIndex] = normalizedDirection;
			vectorIndex++;
		}
		else if (level > maxTrail)
		{
			maxTrail = level;
			vectorIndex = 0;
			vectors[vectorIndex] = normalizedDirection;
			vectorIndex++;
		}
	}

	float2 agentDirection;
	if(maxTrail >= trailDetectionThreshold)
	{
		const int index = (vectorIndex - 1) * round(rand(id.xx * .01 + sin(time)).x);
		agentDirection = vectors[index];
	}
	else 
	{
		agentDirection = randDir(id.xx * .01 + sin(time));
	}
	return normalize(agentDirection);
}
////////////////////////////// KERNELS ////////////////////////////////////////

[numthreads(NUMTHREADS_RESOLUTION, NUMTHREADS_RESOLUTION, 1)]
void ResetTextureKernel(uint3 id : SV_DispatchThreadID) 
{
	writeTexture[id.xy] = 0.0;
}

[numthreads(NUMTHREADS_AGENTS, 1, 1)]
void ResetAgentsKernel(uint3 id : SV_DispatchThreadID)
{
	Agent agent;

	if(randomReset)
	{
		agent.position = rand(id.xx * .001 + time * .001) * (float)resolution;
	}
	else
	{
		for(int i = 0; i < 1000; i++) //tries
		{
			const float2 randUV = rand(id.xx * .001 + (time + (float)i)* .001);
			agent.position = randUV * (float)resolution;
			const float4 resetValue = resetTexture.SampleLevel(sampler_resetTexture, 1 - randUV, 0);
			float average = (resetValue.x + resetValue.y + resetValue.z) * .333;
			if (rand(id.xx * .01 + sin(time + (float)i)).x < average) break;
		}
	}

	agent.direction = randDir(id.xx * .01 + sin(time));
	agents[id.x] = agent;
}

[numthreads(NUMTHREADS_AGENTS, 1, 1)]
void TrailsKernel(uint3 id :  SV_DispatchThreadID)
{
	Agent agent = agents[id.x];
	writeTexture[round(agent.position)] = saturate(writeTexture[round(agent.position)] + trailStrengthPerAgent);
}

[numthreads(NUMTHREADS_RESOLUTION, NUMTHREADS_RESOLUTION, 1)]
void DecayKernel(uint3 id : SV_DispatchThreadID)
{
	float average = .0;
	for (int y = -1; y <= 1; y++)
	for (int x = -1; x <= 1; x++)
	{
		const float2 uv = (int2(id.x, id.y) + int2(x, y)) / (float)resolution;
		average += readTexture.SampleLevel(sampler_readTexture, uv, 0).r;
	}

	average /= 9.0;

	const float result = saturate(average * trailDecayFactor);

	writeTexture[id.xy] = result;
}

[numthreads(NUMTHREADS_AGENTS, 1, 1)]
void MoveAgentsKernel(uint3 id : SV_DispatchThreadID)
{
	Agent agent = agents[id.x];

	agent.direction = NeighborhoodTurns(id, agent);

	agent.position = agent.position + agent.direction;
	agent.position = wrapPosition(agent.position);

	agents[id.x] = agent;
}

[numthreads(NUMTHREADS_RESOLUTION, NUMTHREADS_RESOLUTION, 1)]
void RenderKernel(uint3 id :  SV_DispatchThreadID)
{
	const float trail = readTexture[id.xy].r;
	const float4 color = lerp(dimColor, brightColor, trail);
	outTexture[id.xy] = float4(color.r, color.g, color.b, 1.0);
}